# openGauss安全设计指南
本规范主要参考业界广泛标准和开源最佳实践，结合openGauss业务发展趋势，制定出openGauss安全设计指南，用于指导开发者进行模块设计，避免出现高安全设计风险。

## 1. 身份管理
1.1 系统禁止预留任何的未公开帐号，所有帐号都必须可被系统管理，并在资料中提供所有帐号及管理操作说明。  
**说明**:预留的未公开帐号易被用户质疑为后门。为帐号提供基本的维护功能，否则管理员无法感知系统所有帐号，无法对帐号进行维护  

1.2 应用系统人机帐号、机机帐号分离，用于程序间通信的机机帐号不能作为系统维护的人机帐号。  
**说明**：人机帐号和机机帐号的管理要求不同，如果不分离，将出现帐号管理的混乱。  

1.3 系统安装、初始化配置过程中使用到的临时帐号，在系统安装、初始化配置完成后，自动删除或者提供手工删除的指导书。  
**说明**：临时帐号和测试帐号在系统正常使用中不需要用到，删除这些帐号能有效减小攻击面。  

1.4 数据库若存在多个默认帐号，必须将不使用的帐号禁用或删除。若无法删除或禁用，须在产品资料中提示修改默认帐号的口令并定期更新。  
**说明**：数据库默认帐号名称被他人知晓，容易受到暴力破解的攻击，禁用或删除这些帐号能有效减小攻击面。另外这些默认帐号的权限过大，容易造成越权访问数据。  

1.5 产品出厂使用的第三方和开源软件禁止使用缺省口令。  
**说明**：第三方和开源软件提供的缺省口令，特别是数据库帐号的缺省口令，已广泛公开并存在于口令破解工具的字典中，在现网中使用存在极大的安全隐患。禁用这些缺省口令能有效降低口令被破解的风险。  

1.6 系统提供口令安全策略可配置的功能。  
**说明**：长期使用同一个口令会增加被暴力破解和恶意猜测的风险，口令的安全策略就是限制用户使用同一个口令的时间，从而降低了暴力破解的风险。  

1.7 系统禁止明文显示口令。  
**说明**：系统明文打印口令时，会被他人通过窥视的方式获得口令，造成信息泄露，从而用户身份被仿冒;内存中的明文口令使用后覆盖，防止因堆检查攻击获得内存中保存的口令明文，导致信息泄露，从而用户身份被仿冒

1.8 禁止系统运行后存在缺省口令。  
**说明** 系统运行后禁止用户使用缺省口令登陆，存在缺省口令的首次登陆需要强制用户修改口令。

## 2. 认证管理
2.1 所有能对系统进行管理的人机接口以及跨信任网络的机机接口必须有安全的接入认证机制并缺省启用，标准协议没有认证机制的除外。设备外部可见的能对系统进行管理的物理接口必须有接入认证机制。  
**说明**：如果没有认证，就不知道对系统进行管理的用户是谁，也就不能对其进行权限的控制，并且无法对其行为进行审计。 

2.2 对用户的最终认证处理、鉴权处理过程必须在服务器端进行，并遵从先鉴权后执行的原则。  
**说明**：认证的处理过程在客户端实现是不可靠的，防止通过代理、篡改报文等方式绕过认证机制；为了防止鉴权机制被绕过，鉴权处理过程必须放在服务器端完成。鉴别用户权限和角色的数据也必须存放在服务器端，不能存放在客户端。 

2.3 认证失败后，登录界面以及认证服务端返回信息均不能提供详细的、可用于判断具体错误原因的提示。  
**说明**：认证失败后的提示信息中可能包含可以被攻击者利用的信息，比如如果攻击者通过提示信息知道了某个帐号是存在的，就可以针对该帐号进行暴力破解。

2.4 管理面所有的用户的连接过程（登录成功、登录失败、登出）、系统对用户的锁定（包括自动锁定和管理员手动锁定）操作、系统对用户的解锁（包括自动解锁和管理员手动解锁）操作，均要记录日志，不得存在对特别用户进行特殊处理。  
**说明**：对认证过程中涉及的操作计入日志，以便后续的审计。

## 3. 授权管理
3.1 新建帐号默认不授予任何权限或者默认只指派最小权限的角色。  
**说明**：防止授权机制出现问题或授权机制被绕过时用户的获得权限也是最少的，以尽可能减少出现问题时系统遭受的风险。 

3.2 系统中各帐号的权限需满足“权限最小化”原则。  
**说明**：防止因帐号权限过大导致越权。

3.3 软件程序执行从文件中读取的命令或调用外部脚本时要严格限制该文件的脚本的修改权限，防止注入攻击。  
**说明**：防止命令注入攻击，低权限攻击者可以尝试在输入文件中写入代码，提升自己的权限。

3.4 运行软件程序的帐号要尽可能的使用操作系统低权限的帐号。  
**说明**：防止程序本身出现漏洞时攻击者获得管理员的权限。

3.5 属于低权限用户的脚本或程序不能以高权限帐号运行，以高权限运行的脚本或程序只允许其属主拥有写权限。  
**说明**：防止低权限用户篡改软件或脚本来越权到高权限帐号。

## 4. 数字证书管理
4.1 使用安全随机数生成密钥对，且必须使用至少2048位的RSA密钥对（第三方CA签发证书、与第三方系统对接、兼容老版本等场景可例外）。  
**说明**：在生成密钥对时如果使用不安全的随机数会导致密钥容易被猜测，影响密钥的安全性，所以在生成密钥对时，应使用密码学意义上的安全随机数，保证密钥对的不可预测性。如果产品支持使用硬件随机数接口宜尽量使用硬件接口来产生随机数。

## 5. 会话管理
5.1 系统应支持“根据帐号、角色、IP地址、时间等特征来确定是否允许通过认证建立认证后的会话”。  
**说明**：防止资源被非必须因素占用；防止非工作时间黑客攻击系统。

5.2 管理员能查看到当前已成功建立会话的用户信息并能够终止指定用户会话。  
**说明**：如果黑客攻击成功可以有办法对其进行制止。

5.3 当服务器检测到非法会话，则服务器拒绝响应或返回到认证界面，同时需要记录安全日志。  
**说明**：防止攻击者使用窃取的会话标识冒充用户。

5.4 必须设置会话超时机制，在超时过后必须要清除该会话信息。  
**说明**：及时回收资源，减少会话劫持的时间窗；会话超时默认指会话空闲超时机制，当会话空闲超过一定时间后，系统应该注销当前会话；会话固定超时机制是指系统在创建会话时，设定了会话的最大可用时间；会话更新超时机制是指会话创建后经过指定的更新超时时间，由系统对当前的会话ID进行更新。

## 6. 密码算法
6.1 禁止使用私有的、非标准的密码算法。  
**说明**：私有的非标准的算法不被业界公知和信任，可能存在算法缺陷，无法起到对数据加密保护的作用。

6.2 禁止使用业界已知不安全的加密算法，推荐使用强密码算法。  
**说明**：弱密码算法已经被密码分析者破解或者部分破解，使用不再安全的算法无法起到对数据加密保护的作用。  
**事例**：
| 用途 | 不安全密码算法 | 推荐的强密码算法 |
|-|-|-|
| 对称加密| 分组加密：Blowfish, DES, DESX, RC2, Skipjack, 2TDEA, TEA, 3DES / 流加密：SEAL, CYLINK_MEK, RC4 | 分组加密：AES-GCM(≥128 bits) / 流加密：AES-CTR(≥128 bits), AES-OFB(≥128 bits), chacha20-poly1305 |
| 哈希算法 | SHA0, MD2, MD4, MD5, SHA1(数字签名、Hash-only场景),RIPEMD, RIPEMD-128 |  SHA256或以上, SHA3-256或以上 |
| 非对称加密 | RSA (< 2048 bits), ECIES (< 224bits) | RSA(≥3072 bits), ECIES (≥256 bits) |
| 数字签名 | RSA (< 2048 bits), DSA (同X9.42标准DH), ECDSA(<224bits) | RSA(≥3072 bits), DSA(同X9.42标准DH), ECDSA(≥256 bits), EdDSA(≥256 bits) |
| 密钥协商 | DH：L<2048 bits, N*<224 bits / ECDH: ECDH(< 224bits) | DH：L≥3072 bits, N≥256 bits / ECDH: ECDH(≥256 bits) |

6.3 密码算法中使用到的随机数必须是密码学意义上的安全随机数。  
**说明**：随机数是密码学的基础，密钥的随机性确保攻击者无法猜测密钥，也就无法解密密文；盐值的随机性确保攻击者无法执行预计算操作，也就无法构造彩虹表进而还原口令明文；IV的随机性确保攻击者无法找出密文的统计学特性，也就无法进行密文替换攻击或注入攻击。如果随机性无法保证，上面提到的各种攻击都能奏效，系统的安全性就会受到极大威胁。推荐的安全随机数生成器：OpenSSL1.1.X的RAND_pri_bytes、OpenSSL FIPS模块中实现的DRBG、JDK的java.security.SecureRandom等。典型的不安全随机数生成器：C标准库函数random()、rand()、Java的java.util.Random。

6.4 对口令进行单向哈希时，必须使用基于口令的密钥派生算法。  
**说明**：单纯的口令哈希值，无法防止彩虹表攻击。哈希加盐可以防止彩虹表攻击，但无法防止暴力攻击，安全性仍不足，标准的基于口令密钥派生算法考虑了彩虹表攻击和暴力攻击的防范，更为安全。

## 7. 密钥管理
7.1 对密钥做加密的密码算法的安全强度不小于被加密密钥本身所用于密码算法的安全强度。  
**说明**：密钥指被加密对象，如果加密该密钥时所用加密算法安全强度低于该密钥本身所用于的密码算法的安全强度，则攻击者可以绕开密钥本身所用于的加密算法，转而攻击加密该密钥的加密算法获取该密钥明文，在安全上形成了短板。

7.2 密钥的用途需单一化，即一个密钥应只用于一种用途。

7.3 用于对数据进行加密的密钥不能在代码中硬编码。  
**说明**：密钥要支持替换，避免长期使用增加被泄露风险。  

## 8. 隐私保护
8.1 禁止在未经授权（签订数据转移协议或获得客户的明确同意等）前进行个人数据转移，产品出于定位问题目的从客户网络导出包含个人数据的数据时须对个人数据进行过滤、或匿名化或假名化处理。

8.2 涉及个人数据的采集/处理的功能须提供安全保护机制（如认证、权限控制、日志记录等），并通过产品资料向客户公开。

8.3 收集或使用个人数据前，必须明确提示用户，并获得用户的同意，并且允许用户随时关闭对个人数据的收集和使用。

8.4 个人数据收集范围、使用目的不得超出隐私声明，且遵循最小化原则，当个人数据的采集范围、使用目的发生变更时，应及时更新隐私声明。
**说明**：防止日志中存放了个人数据，但是日志本身的安全性保障不足，导致个人数据泄露。

8.5 认证凭据(如口令、密钥等)不允许明文存储在系统中，应该加密保护，在不需要还原明文的场景，应使用安全的不可逆算法加密，如果需要还原，则可以使用安全的对称加密算法和安全的加密模式加密。  

## 9. 日志审计
9.1 管理面所有对系统产生影响的用户活动、操作指令必须记录日志，日志内容要能支撑事后的审计，记录包括用户ID、时间、事件类型、被访问资源的名称、访问发起端地址或标识、访问结果等；日志要有访问控制，应用系统禁止提供手动删除、修改审计日志的能力。
**说明**：可以帮助回溯历史操作，提高现网问题定位的效率。

## 10. 安全传输
10.1 在非信任网络之间进行敏感数据的传输须采用安全传输通道或者加密后传输，有标准协议规定的除外。  
**说明**：在跨网络进行传输时，容易遭受攻击者窃取或篡改，需要对重要数据进行保护。    

10.2 不应使用SSL2.0、SSL3.0、TLS1.0、TLS1.1协议进行安全传输，推荐使用更安全协议TLS1.2和TLS1.3。  
**说明**：SSL2.0和SSL3.0协议因存在很多安全问题已分别于2011年3月和2015年6月被IETF禁用。TLS1.0协议中对称加密算法仅支持RC4算法和分组加密算法的CBC模式，RC4已经公认不安全并被IETF在TLS所有版本协议中禁用，而对称算法的CBC模式存在IV可预测的问题，从而容易受到BEAST攻击。因此，推荐使用TLS1.2和TLS1.3协议。